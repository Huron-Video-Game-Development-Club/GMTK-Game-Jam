<!DOCTYPE html>
<html>
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cabin&family=Roboto:wght@500&display=swap" rel="stylesheet">
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
   
    <style>
        *{
            font-family: "Roboto", sans-serif;
            font-size: 16px;
        }

        .green{
            color: white;
            background-color: #1E555C;
        }

        .pilled{
            border-radius: 20px;
            padding-left: 5px;
            padding: 10px;
            padding-right: 5px;
        }
    </style>
</head>
<body style="padding: 0px; margin: 0px;">
    <div id="overlay"></div>
    <script>
    var width = 800;

    var height = 800;
        
    var config = {
        type: Phaser.AUTO,
        width: width,
        height: height,
        pixelArt: true,
        physics: {
            /*default: 'arcade',
            arcade: {
                gravity: { y: 0 }
            }*/
            default: 'matter',
            matter:{
                gravity:{
                    x: 0,
                    y: 0
                },
                debug:{
                    showBody: true,
                    showStaticBody: true
                }
            }
            
        },
        scale: {
    parent: 'game-container',
    mode: Phaser.Scale.HEIGHT_CONTROLS_WIDTH,
    autoRound: true,
    autoCenter: Phaser.DOM.CENTER_BOTH,
  },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    //game and UI overlay
    var game = new Phaser.Game(config);
    var overlay;
    window.onload = function(){
        var canvas = document.querySelector("canvas");
        let dim = canvas.getBoundingClientRect()

        var overlay = document.getElementById("overlay");
        overlay.style.position = "absolute";
        overlay.style.left = dim.x + "px";
        overlay.style.top = dim.y + "px";
        overlay.style.height = dim.height + "px";
        overlay.style.width = dim.width + "px";
        //Arrow Keys to Move instruction
        overlay.innerHTML += `<div id="instr_one" style="position: absolute; top: 200px; left: 300px;" class="pilled green">
            <t style="padding: 0px;">Arrow Keys to Move</t>
            </div>
            `
        overlay.innerHTML += `<div id="instr_two" style="position: absolute; display: none; top: 200px; left: 200px;" class="pilled green">
            <t style="padding: 0px;">Spacebar when near the die to kick it</t>
            </div>

        <div id="instr_three" style="position: absolute; display: none; top: 200px; left: 200px;" class="pilled green">
            <t style="padding: 0px;">Use the power of the die to CRUSH THINE ENEMIES! Good luck...</t>
            </div>
        <div id="instr_three-btn" style="position: absolute; display: none; top: 400px; left: 200px; border-radius: 5px;" class="pilled green">
            <t style="padding: 0px;">Hold Space to Start</t>
            </div>
            `
        overlay.innerHTML += `
            <div id="gameData" style="display: none;">
                <div style="position: absolute; top: 30px; left: 10px; border-radius: 5px;" class="pilled green">
                    <t style="padding: 0px;" id="kickCount">Kicks remaining: </t>
                </div>
                <div style="position: absolute; top: 70px; left: 10px; border-radius: 5px;" class="pilled green">
                    <t style="padding: 0px;" id="enemyCount">Enemies remaining: </t>
                </div>
            </div>

        `
        
       // overlay.style.backgroundColor ="blue";
    }

    //game constants
    //Experiment with these!
    const FRICTION = 0.005; //0-1 where 0 is no friction
    const BOUNCE = 0.9; //0-1 where 1 means 100% of kinetic energy is retained on bounce by dice
    const FORCE = 10; //Initial force of dice kick
    var SPEED = 3; //Player speed

    //global variables for game objects and other stuff
    var player;
    var keys;
    var idleAnim;
    var runAnim;
    var platforms;
    var dice;
    var daves = [];
    var slimes = [];
    var stage = "tutorialPt1";
    var stageCompleted = false;
    var enemyCount = 1;
    var kickCount = 2;
    var arrow;
    var interactable = true;


    var isAlive = true;

    //helper method to load a spritesheet from Data URI
    function loadSheet(game, name, dataURI, width, height){
        console.log("NEW");
        var img = new Image();
        img.onload = function(){
            game.textures.addSpriteSheet(name, img, {frameWidth: width, frameHeight: height});
        }
        img.src = dataURI;
    }

    //gets the normalized vector from p1 to p2 times given magnitude
    function getForceVector(p1, p2, magnitude){
        let d = Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y));
        return {x: ((p2.x - p1.x)/d) * magnitude, y: ((p2.y - p1.y)/d) * magnitude};
    }

    //returns true or false as to whether a given matter sprite was involved in the collision data
    function wasInvolved(sprite, data){
        return (data.bodyA.name == sprite.body.name || data.bodyB.name == sprite.body.name);
    }

    function wasInvolvedShape(shape, data){
        return (data.bodyA.name == shape.name || data.bodyB.name ==  shape.name);
    }

    //updates the kick and enemy counts and the UI based on the values given
    function updateKickAndEnemyCounts(newKicks, newEnemies){
        enemyCount = newEnemies;
        kickCount = newKicks;
        document.getElementById("enemyCount").innerHTML = "Enemies remaining: " + enemyCount;
        document.getElementById("kickCount").innerHTML = "Kicks remaining: " + kickCount;  
    }

    function resetDice(){
        dice.setScale(1);
        dice.detector.setScale(2.5);
        setTimeout(function(){
            for (slime of slimes){
                slime.destroy();
            }
            slimes = [];
        }, 3000);
        clearInterval(dice.slimeAnim);
    }
        
    //loads the stage with the given name
    function loadStage(name, game){
        switch(name){
            case "tutorialPt2":
                document.getElementById("instr_one").style.display = "none";
                document.getElementById("instr_two").style.display = "block";
                break;
            case "tutorialPt3":
                document.getElementById("instr_two").style.display = "none";
                document.getElementById("instr_three").style.display = "block";
                document.getElementById("instr_three-btn").style.display = "block";
                break;
            case "one":
                document.getElementById("instr_three").style.display = "none";
                document.getElementById("instr_three-btn").style.display = "none";
                player.setPosition(400, 600);
                resetDice();
                dice.setPosition(400, 400);
                dice.setRotation(0);
                dice.detector.setPosition(400, 400);
                dice.setVelocity(0, 0);
                dice.setAngularVelocity(0);
                createDave(game, 200, 200);
                updateKickAndEnemyCounts(200, 1);
                document.getElementById("gameData").style.display = "block";
                break;
        }
    }

    //transitions to given stage
    function stageTransition(name, game=null, delay=1500){
        stageCompleted = true;
        window.setTimeout(function(){
            stage = name;
            stageCompleted = false;
            loadStage(name, game);
        }, delay);
    }

    function getRandomUnitVector(){
        let x = Math.random();
        let y = Math.sqrt(1 - x * x);
        return {x: x, y: y};
    }

    function getSpeed(sprite){
        return Math.sqrt(sprite.body.velocity.x * sprite.body.velocity.x + sprite.body.velocity.y * sprite.body.velocity.y);
    }

    //creates a new dave enemy and appends it to daves
    function createDave(game, x, y){
        dave = game.matter.add.sprite(250, 250, "dave_idle");
        dave.setScale(2);
        dave.setSensor(true);
        dave.play("dave_idle");
        dave.body.name = "dave";
        dave.moveRight = true;
        dave.index = daves.length;
        dave.update = function(){

            if (dave.body.position.x > 600 && dave.moveRight){
                dave.moveRight = false;
            }
            else if (dave.body.position.x < 100 && !dave.moveRight){
                dave.moveRight = true;
            }
            
            if (dave.moveRight){
                dave.setVelocityX(2);
            }
            else{
                dave.setVelocityX(-2);
            }
        }
        daves.push(dave);
        dave.setOnCollideActive((data)=>{
            console.log("collision");
            if (wasInvolved(player, data)){
                player.visible = false;
                isAlive = false;
            }
            else if (wasInvolved(dice, data)){
                daves[dave.index] = 0;
                let base = getForceVector(dice.body.position, dave.body.position, 1);
                dice.setVelocity(-base.x * getSpeed(dice), -base.y * getSpeed(dice));
                dice.activate();
                dave.destroy();
                updateKickAndEnemyCounts(kickCount, enemyCount - 1);
            }
        });
        return dave;
    }


    function createExplosion(game, x, y){
        var explosion = game.matter.add.sprite(x, y, "dice");
        explosion.visible = false;
        explosion.setSensor(true);
        var explosionScale = 1;
        setInterval(function(){
            explosionScale += 0.02;
            explosion.setScale(explosionScale)
        }, 20);
        setTimeout(function(){
            explosion.destroy();
        }, 2000);
        explosion.setOnCollideActive((data)=>{
            if (wasInvolved(player, data)){
                player.visible = false;
                isAlive = false;
               // console.log("WE GOT EM");
            }
        });
    }

    function createSlime(game, x, y){
        var slime = game.matter.add.sprite(x, y, "dice");
        slime.visible = false;
        slime.setSensor(true);
        slime.setOnCollideActive((data)=>{
            if (wasInvolved(player, data)){
                player.inSlime = true;
               // console.log("WE GOT EM");
            }
        });

        slime.setOnCollideEnd((data)=>{
            if (wasInvolved(player, data)){
                player.inSlime = false;
            }
        });

        slimes.push(slime);
    }

    function preload(){
        
        let uri1 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAYCAYAAAC8/X7cAAAAAXNSR0IArs4c6QAAARxJREFUWEftl8sNAjEMRHePNMKZUiiAPqiBPiiAUjjTCEdQkCKZ7Nozjs1nBVxxZvIyJDbjsPDPuPD9D18JcNrsbuVgt+cj3B8smEvIY+BNuGrXdQjCDeA18AC02gyEC6DH4GcAtMNBKdAJ9BowCSBtC4ICiBggAFZbe5UgQNTAAvBoaymYABkGGoDU3l8vj7LDao0Cm/QGFSDLwOoj9bsWAAHJ3jAL0J58xKAFYFINAWQb9ADA35EYMyYJMAAeA1mbpS1fpCeAVxj8AZS460V+awJlL9GU2+k0/Q6g8bceqBzJ56CqDhrdYR8oQhED1MgQcAoAMw6gjWjPKVrXBSBP3DJg66xeENWHd0Az6P1nxq5j6+A0yjStT9bcAc3f6Bk+Ifp6AAAAAElFTkSuQmCC";
        loadSheet(this, 'idle', uri1, 24, 24);

        let uri2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAAXNSR0IArs4c6QAAAb5JREFUaEPtmMFVxDAMRNkjjeyZUiiAPqhh+6AASuFMIxzhhff8njGRZsaSdhMIR+wdjefLiZ3T3fF30wRON61uFH99ePpchh7fXjbpD2Wm+J9aoFIAmR3Hm3b7fwWELfmXAVQGNGpXQNiafwlAdUD/UX8zAKzwM3dBJeBZ/zSA2QLMOwBpZ0BANSLvGqTt+acARAogAKx25FTE1piBwGpb/iGAaAEPgKI9uwuUGioARdvy7wLIKGAB6LWfP96/p13uz2jDSHeDPfg3AVQGNAYzAkBAmE7di/9VAJUBMV0ZBbAn/78AVAfE6MPnkPOZgtGPAGb0Ff9TAJQC/dws896JKKvG2mMuS7v3/wNARYFrAtij/wOAsZ3/5A5Y1hrtUu8EFNXuWVh1ojVG3fR3gHpEXOavLarpeGNrzZsdELrHeP57L1Yu8B7ABsQE3xbTjLG/GUNlftfXYAAzmt77zHtkedrUTRhtR8U80xVM1zEnMQQajSufUcYM2HVeFcBMJ48hLBoscBQwGp+FrKwTPoKsMzdLmFlExRzkD40rnpSmGHWpTxHe9vIuRcoiMueiDkTjmV6QFvwcjQSO8VgCX5sy1ChabDngAAAAAElFTkSuQmCC";
        loadSheet(this, 'run', uri2, 24, 24);
        
        this.load.spritesheet('idle', 'https://google.com/idledsfndsl', {frameWidth: 24, frameHeight: 24}); 

        //this.load.image("rock", "/rock.png");
        let uri3 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHFJREFUSEtjrKvr/89AQ8AIsqCpqZCRFnaAzKafBehBRQ1fofhg0FlAjIMo8gHJFpCaiga3BYQyH7EpDGc+GLUAlmCoFkTIQYocP6MWEMybVC2useVs+luAKzVgCwt0tUT5YFBbgMuX9KmTCaY3ChQAAE8nCRgzzg/uAAAAAElFTkSuQmCC";
        this.textures.addBase64("rock", uri3);

        let uri4 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAAAXNSR0IArs4c6QAAAN9JREFUeF7t1LEJg1AYRlGdQXCKVBnAER3KcQRniKSPiXC7cF7/msv5v/HxXF+Dd1lgfAea5kWiDwWOfRsE+kJDoB93I5BAbVoJIoigVoCg1s8GEURQK0BQ62eDCCKoFSCo9bNBBBHUChDU+tkggghqBQhq/WwQQQS1AgS1fjaIIIJaAYJaPxtEEEGtAEGtnw0iiKBWgKDWzwYRRFArQFDrZ4MIIqgVIKj1s0EEEdQKENT62SCCCGoFCGr9bBBBBLUCBLV+NogggloBglo/G0QQQa0AQa2fDborqHX+798n0vBccM0SKBcAAAAASUVORK5CYII="
        this.textures.addBase64("dice", uri4);

        //this.load.spritesheet("dave_idle", "/dave.png", {frameWidth: 24, frameHeight: 24});
        let uri5 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAAAYCAYAAAAF6fiUAAAAAXNSR0IArs4c6QAAAcxJREFUaEPtmeGNwzAIhdOJboNuk6myTTe4iVr5JFeci+GBwc6d0l+VXD3w9wDXyW27PksJ3JZGTwz+eHw/Ufn7/WsZh2WBUTjW31nAt9orjGAN8GzCknyWvkfXY4InTo/PLwM8wpYN/AX9sp8erIz83wZEiFczuA1k65fYUTFm5p9iAFdFUXB6JkfqZxtA+VwGMKf8dAMiq4er0Gx9afzs+/5GfBzHB+66TtdaAzLz/+mAzAAz9P+1AWgFFQi9KpIMjtDXTOaqvLZCWWs7w9IBo/mrHTAaAIXTGkgB1e+zxsSpDCib1yqIg0c3oY24UX3NZOtt2mLAKB+1A6zJrzqEkXOgHTU9460GeBjVGFMM0Cq0B0LqDPS2SkdoD5R2BmTmD90DogBxowgBpI04CraNgegjBvRMQPSl/NVnQaMBJDh0fmptjELiQGl7kA737PynGuCtIgv8CgztNqs2qkuNk2J8PI6ODsBVdu9fEVep3O0VffSt/fvickO0I/M3vQ84A6ACDYEkdUJv3Fl0tYNZGqk0jvhGzFNBmYCs2hYTrPAt2tSMNo76StJqgmcjaAyPtna4R6yP5K8aYGm1swKKgJylARmQFfzS3bYX7jPIKJDp3YMAAAAASUVORK5CYII="
        loadSheet(this, 'dave_idle', uri5, 24, 24);

        let uri6 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAADFJREFUKFNjZCAAGJHlNxjE/AfxAy4sgYvDGTBJmAaYIrACdElkRYy4JGGKqKCAkDcB/2USujWLhUMAAAAASUVORK5CYII="
        this.textures.addBase64("arrow", uri6);
    }


    function create(){
        keys = this.input.keyboard.createCursorKeys();
        spacebar = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        idleAnim = this.anims.create({
            key: 'idle',
            frames: this.anims.generateFrameNumbers('idle', {start: 0, end: 3}),
            frameRate: 4,
            repeat: -1
        });

        runAnim = this.anims.create({
            key: 'run',
            frames: this.anims.generateFrameNumbers('run', {start: 0, end: 3}),
            frameRate: 8,
            repeat: -1
        });

        daveIdle = this.anims.create({
            key: 'dave_idle',
            frames: this.anims.generateFrameNumbers('dave_idle', {start: 0, end: 3}),
            frameRate: 8,
            repeat: -1
        });

        //createDave(this, 200, 200);


        player = this.matter.add.sprite(400, 600, 'run');
        player.canDash = true;
        player.dashing = false;
        player.setScale(2);
        player.isMoving = {x: false, y: false};
        player.setFixedRotation();
        player.setMass(1);
        player.body.name = "player";

        arrow = this.matter.add.sprite(400, 550, 'arrow');
        arrow.setScale(2);
        arrow.setSensor(true);

        dice = this.matter.add.sprite(400, 400, "dice");
        dice.rotateNum = 0;
        dice.colors = ['0x52ffb8', '0xe85f5c', '0x69385c', '0x006d77', '0xec9f05', '0xFBF2C0'];
        dice.setRotation(Math.PI/4);
        dice.setMass(100000);
        dice.setFriction(0);
        dice.setFrictionAir(FRICTION);
        dice.setBounce(BOUNCE);
        dice.tintFill = true;
        dice.clearTint();
        dice.elapsed = 0;
        dice.body.name = "dice";
        dice.detector = this.matter.add.sprite(400, 400, "dice");
        dice.detector.name = "detector";
        dice.detector.setScale(2.5);
        dice.detector.visible = false;
        dice.detector.setSensor(true);

        enmie = this.matter.add.sprite(300, 100, "dice");
        enmie.setScale(0.9, 0.9);
        enmie.setRotation(Math.PI/4);
        enmie.setMass(100000);
        enmie.setAngularVelocity(2);
        enmie.setFriction(0);
        enmie.setBounce(1);
        enmie.setVelocity(10,10)
        enmie.tintFill = true;
        enmie.clearTint();
        enmie.body.name = "dice";


        //create edges of playing area
        var rightEdge = this.matter.add.rectangle(800, 0, 100, 1600, {isStatic: true});
        rightEdge.name = "rightWall";
        var leftEdge = this.matter.add.rectangle(0, 0, 100, 1600, {isStatic: true});
        leftEdge.name = "leftWall";
        var upEdge = this.matter.add.rectangle(0, 0, 2000, 100, {isStatic: true});
        upEdge.name = "upWall";
        var downEdge = this.matter.add.rectangle(0, 800, 2000, 100, {isStatic: true});
        downEdge.name = "downWall";


        //collision events

        //player kick
        dice.detector.setOnCollideActive((data)=>{
            if (wasInvolved(player, data)){
                player.canDash = false;
            }

            if (keys.space.isDown && interactable && wasInvolved(player, data) && kickCount > 0){
                
                if (dice.num == 1){
                    dice.slimeAnim = setInterval(function(){
                        createSlime(self, dice.body.position.x, dice.body.position.y);
                    }, 100);
                }
                else if (dice.num == 2){
                    dice.rotateNum = 0;
                    dice.flashAnim = setInterval(function(){
                        if (dice.rotateNum == 0){
                            dice.rotateNum = 1;
                            dice.setTintFill("0xFFFFFF");
                        }
                        else{
                            dice.rotateNum =  0;
                            dice.setTintFill("0xe85f5c");
                        }
                    }, 200);
                    var self = this;
                    setTimeout(function(){
                        createExplosion(self, dice.body.position.x, dice.body.position.y);
                        clearInterval(dice.flashAnim);
                    }, 2000);
                }

                var newVelocity = getForceVector(player.body.position, dice.body.position, FORCE);
                console.log(newVelocity);
                dice.setVelocity(newVelocity.x, newVelocity.y);

                dice.state = "action";
                dice.loadedState = false;
                dice.setAngularVelocity(0.2);
                //dice.setTintFill(0xECA72C);
                interactable = false;
                if (stage == "tutorialPt2" && !stageCompleted){
                    stageTransition("tutorialPt3", this);
                }

                updateKickAndEnemyCounts(kickCount - 1, enemyCount);
                
            }
        });

        dice.detector.setOnCollideEnd((data)=>{
            if (wasInvolved(player, data)){
                player.canDash = true;
            }
        });

        // enmie.detector.setOnCollideActive((data)=>{
        //     if (keys.space.isDown && interactable && wasInvolved(player, data) && kickCount > 0){
        //         var newVelocity = getForceVector(player.body.position, enmie.body.position, FORCE);
        //         console.log(newVelocity);
        //         enmie.setVelocity(newVelocity.x, newVelocity.y);
        //         console.log("DID IT");
        //         enmie.setAngularVelocity(0.2);  
        //         enmie.setTintFill(red);
        //         interactable = false;
        //         if (stage == "tutorialPt2" && !stageCompleted){
        //             stageTransition("tutorialPt3", this);
        //         }

        //         updateKickAndEnemyCounts(kickCount - 1, enemyCount);
                
        //     }
        // });
        dice.state = "selecting";
        dice.loadedState = false;

        var self = this;
        dice.activate = function(){
            let num = 2//Math.floor(Math.random() * 6) + 1;
            dice.num = num;
            dice.setTintFill(dice.colors[num - 1]);
            dice.loadedState = true;
            interactable = true;
            switch(num){
                case 1:
                    break;
                case 2:
                    break;
                case 3:
                    
                    break;
                case 4:
                   
                    break;
                case 5:
                    dice.setScale(2.5);
                    dice.detector.setScale(3.125);
                    break;
                case 6:
                    break;
            }
            var text = self.add.text(dice.body.position.x, dice.body.position.y, num);
            
            setTimeout(function(){
                text.destroy();
            }, 2000);
        }
       /* dice.setOnCollideWith(rightEdge, (data)=>{
            if (!interactable){
                dice.activate();
            }
        });

        dice.setOnCollideWith(leftEdge, (data)=>{
            if (!interactable){
                dice.activate();
            }
        });

        dice.setOnCollideWith(upEdge, (data)=>{
            if (!interactable){
                dice.activate();
            }
        });

        dice.setOnCollideWith(downEdge, (data)=>{
            if (!interactable){
                dice.activate();
            }
        });*/




    }

    function update(){

        //player movement stuff
        if (isAlive){
            if (player.inSlime){
                SPEED = 1;
            }
            else{
                SPEED = 3;
            }

            if (player.dashing){
                player.isMoving.x = true;
            }
            else{
                if (keys.left.isDown){
                    player.setVelocityX(-SPEED);
                    player.setFlipX(false);
                    player.isMoving.x = true;
                }
                else if (keys.right.isDown){
                    player.setVelocityX(SPEED);
                    player.setFlipX(true);
                    player.isMoving.x = true;
                }
                else{
                    player.isMoving.x = false;
                    player.setVelocityX(0);
                }

                if (keys.up.isDown){
                    player.setVelocityY(-SPEED);
                    player.isMoving.y = true;
                }
                else if (keys.down.isDown){
                    player.setVelocityY(SPEED);
                    player.isMoving.y = true;
                }
                else{
                    player.isMoving.y = false;
                    player.setVelocityY(0);
                }
            }

            

            if (!player.isMoving.x && !player.isMoving.y){
                player.play('idle', true);
                player.setVelocityX(0);
                player.setVelocityY(0);
            }
            else{
                player.play("run", true);
                if (stage == "tutorialPt1" && !stageCompleted){
                    stageTransition("tutorialPt2", this, 500);
                }
            }

            if (keys.space.isDown && stage == "tutorialPt3" && !stageCompleted){
                stageCompleted = true;
                stageTransition("one", this);
            }

            if (Phaser.Input.Keyboard.JustDown(spacebar) && player.canDash){
                player.setVelocity(player.body.velocity.x * 3, player.body.velocity.y * 3);
                player.dashing = true;
                player.canDash = false;
                setTimeout(function(){
                    player.dashing =  false;
                    player.setVelocity(0, 0);
                    player.canDash = true;
                }, 150); 
            }
            

        // player.play("run");
        }
        
        let speed = Math.sqrt(Math.pow(dice.body.velocity.x, 2) + Math.pow(dice.body.velocity.y, 2))
            
        //max speed of 10
        if (speed > 10){
            dice.setVelocityX((dice.body.velocity.x/speed) * 10);
            dice.setVelocityY((dice.body.velocity.y/speed) * 10);
        }

        dice.detector.setPosition(dice.body.position.x, dice.body.position.y);
        
        
        //make dice usable when slow enough
        if (speed < 1.5 && dice.state != "selecting" && dice.state != "selected"){
            resetDice();
            dice.state = "selecting";
            dice.loadedState = false;
            interactable = false;
           
        } 

        for (dave of daves){
            if (dave != 0){
                dave.update();
            }
        }

        speed = Math.sqrt(Math.pow(enmie.body.velocity.x, 2) + Math.pow(enmie.body.velocity.y, 2))

        if (speed > 14.14)
        {
            enmie.setVelocity(enmie.body.velocity.x / 1.1, enmie.body.velocity.y / 1.1)
        }
        else if (speed < 7.05)
        {
            enmie.setVelocity(enmie.body.velocity.x * 1.1, enmie.body.velocity.y * 1.1)
        }

        //enmie.body.setMaxSpeed(14.14);

        var newArrowPos = getForceVector(player.body.position, dice.body.position, 50);
        arrow.setPosition(player.body.position.x + newArrowPos.x, player.body.position.y + newArrowPos.y);
        let offset = -Math.PI/2;
        if (dice.body.position.x > player.body.position.x){
            offset = Math.PI/2
        }
        arrow.setRotation(Math.atan((dice.body.position.y - player.body.position.y)/(dice.body.position.x - player.body.position.x)) + offset);
    
        enmie.setAngularVelocity(1);
        
        if (dice.state == "selecting" && !dice.loadedState){
            dice.loadedState = true;
            dice.setStatic(true);
            //dice.setTintFill(dice.colors[dice.rotateNum]);
            dice.selectionAnim = window.setInterval(function(){
                dice.rotateNum += 1;
                if (dice.rotateNum > 5){
                    dice.rotateNum = 0;
                }
                dice.setTintFill(dice.colors[dice.rotateNum]);
            }, 200);

            window.setTimeout(function(){
                dice.state = "selected";
                dice.loadedState = false;
                window.clearInterval(dice.selectionAnim);
            }, 2000);
        }
        else if (dice.state == "selecting"){
            dice.setRotation(dice.rotation + 10);
        }
        else if (dice.state == "selected" && !dice.loadedState){
            dice.setStatic(false);
            dice.loadedState = true;
            dice.activate();
        }

    }

    
    </script>

</body>
</html>